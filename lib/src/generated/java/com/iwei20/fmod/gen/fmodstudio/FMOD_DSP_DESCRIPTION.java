// Generated by jextract

package com.iwei20.fmod.gen.fmodstudio;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct FMOD_DSP_DESCRIPTION {
 *     unsigned int pluginsdkversion;
 *     char name[32];
 *     unsigned int version;
 *     int numinputbuffers;
 *     int numoutputbuffers;
 *     FMOD_DSP_CREATE_CALLBACK create;
 *     FMOD_DSP_RELEASE_CALLBACK release;
 *     FMOD_DSP_RESET_CALLBACK reset;
 *     FMOD_DSP_READ_CALLBACK read;
 *     FMOD_DSP_PROCESS_CALLBACK process;
 *     FMOD_DSP_SETPOSITION_CALLBACK setposition;
 *     int numparameters;
 *     FMOD_DSP_PARAMETER_DESC **paramdesc;
 *     FMOD_DSP_SETPARAM_FLOAT_CALLBACK setparameterfloat;
 *     FMOD_DSP_SETPARAM_INT_CALLBACK setparameterint;
 *     FMOD_DSP_SETPARAM_BOOL_CALLBACK setparameterbool;
 *     FMOD_DSP_SETPARAM_DATA_CALLBACK setparameterdata;
 *     FMOD_DSP_GETPARAM_FLOAT_CALLBACK getparameterfloat;
 *     FMOD_DSP_GETPARAM_INT_CALLBACK getparameterint;
 *     FMOD_DSP_GETPARAM_BOOL_CALLBACK getparameterbool;
 *     FMOD_DSP_GETPARAM_DATA_CALLBACK getparameterdata;
 *     FMOD_DSP_SHOULDIPROCESS_CALLBACK shouldiprocess;
 *     void *userdata;
 *     FMOD_DSP_SYSTEM_REGISTER_CALLBACK sys_register;
 *     FMOD_DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister;
 *     FMOD_DSP_SYSTEM_MIX_CALLBACK sys_mix;
 * }
 * }
 */
public class FMOD_DSP_DESCRIPTION {

    FMOD_DSP_DESCRIPTION() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        fmod_studio_h.C_INT.withName("pluginsdkversion"),
        MemoryLayout.sequenceLayout(32, fmod_studio_h.C_CHAR).withName("name"),
        fmod_studio_h.C_INT.withName("version"),
        fmod_studio_h.C_INT.withName("numinputbuffers"),
        fmod_studio_h.C_INT.withName("numoutputbuffers"),
        fmod_studio_h.C_POINTER.withName("create"),
        fmod_studio_h.C_POINTER.withName("release"),
        fmod_studio_h.C_POINTER.withName("reset"),
        fmod_studio_h.C_POINTER.withName("read"),
        fmod_studio_h.C_POINTER.withName("process"),
        fmod_studio_h.C_POINTER.withName("setposition"),
        fmod_studio_h.C_INT.withName("numparameters"),
        MemoryLayout.paddingLayout(4),
        fmod_studio_h.C_POINTER.withName("paramdesc"),
        fmod_studio_h.C_POINTER.withName("setparameterfloat"),
        fmod_studio_h.C_POINTER.withName("setparameterint"),
        fmod_studio_h.C_POINTER.withName("setparameterbool"),
        fmod_studio_h.C_POINTER.withName("setparameterdata"),
        fmod_studio_h.C_POINTER.withName("getparameterfloat"),
        fmod_studio_h.C_POINTER.withName("getparameterint"),
        fmod_studio_h.C_POINTER.withName("getparameterbool"),
        fmod_studio_h.C_POINTER.withName("getparameterdata"),
        fmod_studio_h.C_POINTER.withName("shouldiprocess"),
        fmod_studio_h.C_POINTER.withName("userdata"),
        fmod_studio_h.C_POINTER.withName("sys_register"),
        fmod_studio_h.C_POINTER.withName("sys_deregister"),
        fmod_studio_h.C_POINTER.withName("sys_mix")
    ).withName("FMOD_DSP_DESCRIPTION");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt pluginsdkversion$LAYOUT = (OfInt)$LAYOUT.select(groupElement("pluginsdkversion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int pluginsdkversion
     * }
     */
    public static final OfInt pluginsdkversion$layout() {
        return pluginsdkversion$LAYOUT;
    }

    private static final long pluginsdkversion$OFFSET = $LAYOUT.byteOffset(groupElement("pluginsdkversion"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int pluginsdkversion
     * }
     */
    public static final long pluginsdkversion$offset() {
        return pluginsdkversion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int pluginsdkversion
     * }
     */
    public static int pluginsdkversion(MemorySegment struct) {
        return struct.get(pluginsdkversion$LAYOUT, pluginsdkversion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int pluginsdkversion
     * }
     */
    public static void pluginsdkversion(MemorySegment struct, int fieldValue) {
        struct.set(pluginsdkversion$LAYOUT, pluginsdkversion$OFFSET, fieldValue);
    }

    private static final SequenceLayout name$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char name[32]
     * }
     */
    public static final SequenceLayout name$layout() {
        return name$LAYOUT;
    }

    private static final long name$OFFSET = $LAYOUT.byteOffset(groupElement("name"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char name[32]
     * }
     */
    public static final long name$offset() {
        return name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char name[32]
     * }
     */
    public static MemorySegment name(MemorySegment struct) {
        return struct.asSlice(name$OFFSET, name$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char name[32]
     * }
     */
    public static void name(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, name$OFFSET, name$LAYOUT.byteSize());
    }

    private static long[] name$DIMS = { 32 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * char name[32]
     * }
     */
    public static long[] name$dimensions() {
        return name$DIMS;
    }
    private static final VarHandle name$ELEM_HANDLE = name$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * char name[32]
     * }
     */
    public static byte name(MemorySegment struct, long index0) {
        return (byte)name$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * char name[32]
     * }
     */
    public static void name(MemorySegment struct, long index0, byte fieldValue) {
        name$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final OfInt version$layout() {
        return version$LAYOUT;
    }

    private static final long version$OFFSET = $LAYOUT.byteOffset(groupElement("version"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final long version$offset() {
        return version$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static int version(MemorySegment struct) {
        return struct.get(version$LAYOUT, version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static void version(MemorySegment struct, int fieldValue) {
        struct.set(version$LAYOUT, version$OFFSET, fieldValue);
    }

    private static final OfInt numinputbuffers$LAYOUT = (OfInt)$LAYOUT.select(groupElement("numinputbuffers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int numinputbuffers
     * }
     */
    public static final OfInt numinputbuffers$layout() {
        return numinputbuffers$LAYOUT;
    }

    private static final long numinputbuffers$OFFSET = $LAYOUT.byteOffset(groupElement("numinputbuffers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int numinputbuffers
     * }
     */
    public static final long numinputbuffers$offset() {
        return numinputbuffers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int numinputbuffers
     * }
     */
    public static int numinputbuffers(MemorySegment struct) {
        return struct.get(numinputbuffers$LAYOUT, numinputbuffers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int numinputbuffers
     * }
     */
    public static void numinputbuffers(MemorySegment struct, int fieldValue) {
        struct.set(numinputbuffers$LAYOUT, numinputbuffers$OFFSET, fieldValue);
    }

    private static final OfInt numoutputbuffers$LAYOUT = (OfInt)$LAYOUT.select(groupElement("numoutputbuffers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int numoutputbuffers
     * }
     */
    public static final OfInt numoutputbuffers$layout() {
        return numoutputbuffers$LAYOUT;
    }

    private static final long numoutputbuffers$OFFSET = $LAYOUT.byteOffset(groupElement("numoutputbuffers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int numoutputbuffers
     * }
     */
    public static final long numoutputbuffers$offset() {
        return numoutputbuffers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int numoutputbuffers
     * }
     */
    public static int numoutputbuffers(MemorySegment struct) {
        return struct.get(numoutputbuffers$LAYOUT, numoutputbuffers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int numoutputbuffers
     * }
     */
    public static void numoutputbuffers(MemorySegment struct, int fieldValue) {
        struct.set(numoutputbuffers$LAYOUT, numoutputbuffers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_CREATE_CALLBACK create
     * }
     */
    public final static class create {

        private create() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(create.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_CREATE_CALLBACK create
     * }
     */
    public static final AddressLayout create$layout() {
        return create$LAYOUT;
    }

    private static final long create$OFFSET = $LAYOUT.byteOffset(groupElement("create"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_CREATE_CALLBACK create
     * }
     */
    public static final long create$offset() {
        return create$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_CREATE_CALLBACK create
     * }
     */
    public static MemorySegment create(MemorySegment struct) {
        return struct.get(create$LAYOUT, create$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_CREATE_CALLBACK create
     * }
     */
    public static void create(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create$LAYOUT, create$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_RELEASE_CALLBACK release
     * }
     */
    public final static class release {

        private release() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(release.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(release.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout release$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("release"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_RELEASE_CALLBACK release
     * }
     */
    public static final AddressLayout release$layout() {
        return release$LAYOUT;
    }

    private static final long release$OFFSET = $LAYOUT.byteOffset(groupElement("release"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_RELEASE_CALLBACK release
     * }
     */
    public static final long release$offset() {
        return release$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_RELEASE_CALLBACK release
     * }
     */
    public static MemorySegment release(MemorySegment struct) {
        return struct.get(release$LAYOUT, release$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_RELEASE_CALLBACK release
     * }
     */
    public static void release(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(release$LAYOUT, release$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_RESET_CALLBACK reset
     * }
     */
    public final static class reset {

        private reset() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(reset.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(reset.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout reset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_RESET_CALLBACK reset
     * }
     */
    public static final AddressLayout reset$layout() {
        return reset$LAYOUT;
    }

    private static final long reset$OFFSET = $LAYOUT.byteOffset(groupElement("reset"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_RESET_CALLBACK reset
     * }
     */
    public static final long reset$offset() {
        return reset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_RESET_CALLBACK reset
     * }
     */
    public static MemorySegment reset(MemorySegment struct) {
        return struct.get(reset$LAYOUT, reset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_RESET_CALLBACK reset
     * }
     */
    public static void reset(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reset$LAYOUT, reset$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_READ_CALLBACK read
     * }
     */
    public final static class read {

        private read() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(read.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, int _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_READ_CALLBACK read
     * }
     */
    public static final AddressLayout read$layout() {
        return read$LAYOUT;
    }

    private static final long read$OFFSET = $LAYOUT.byteOffset(groupElement("read"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_READ_CALLBACK read
     * }
     */
    public static final long read$offset() {
        return read$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_READ_CALLBACK read
     * }
     */
    public static MemorySegment read(MemorySegment struct) {
        return struct.get(read$LAYOUT, read$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_READ_CALLBACK read
     * }
     */
    public static void read(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read$LAYOUT, read$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_PROCESS_CALLBACK process
     * }
     */
    public final static class process {

        private process() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(process.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(process.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, int _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout process$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("process"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_PROCESS_CALLBACK process
     * }
     */
    public static final AddressLayout process$layout() {
        return process$LAYOUT;
    }

    private static final long process$OFFSET = $LAYOUT.byteOffset(groupElement("process"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_PROCESS_CALLBACK process
     * }
     */
    public static final long process$offset() {
        return process$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_PROCESS_CALLBACK process
     * }
     */
    public static MemorySegment process(MemorySegment struct) {
        return struct.get(process$LAYOUT, process$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_PROCESS_CALLBACK process
     * }
     */
    public static void process(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(process$LAYOUT, process$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SETPOSITION_CALLBACK setposition
     * }
     */
    public final static class setposition {

        private setposition() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(setposition.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(setposition.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout setposition$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("setposition"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPOSITION_CALLBACK setposition
     * }
     */
    public static final AddressLayout setposition$layout() {
        return setposition$LAYOUT;
    }

    private static final long setposition$OFFSET = $LAYOUT.byteOffset(groupElement("setposition"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPOSITION_CALLBACK setposition
     * }
     */
    public static final long setposition$offset() {
        return setposition$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPOSITION_CALLBACK setposition
     * }
     */
    public static MemorySegment setposition(MemorySegment struct) {
        return struct.get(setposition$LAYOUT, setposition$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPOSITION_CALLBACK setposition
     * }
     */
    public static void setposition(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(setposition$LAYOUT, setposition$OFFSET, fieldValue);
    }

    private static final OfInt numparameters$LAYOUT = (OfInt)$LAYOUT.select(groupElement("numparameters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int numparameters
     * }
     */
    public static final OfInt numparameters$layout() {
        return numparameters$LAYOUT;
    }

    private static final long numparameters$OFFSET = $LAYOUT.byteOffset(groupElement("numparameters"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int numparameters
     * }
     */
    public static final long numparameters$offset() {
        return numparameters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int numparameters
     * }
     */
    public static int numparameters(MemorySegment struct) {
        return struct.get(numparameters$LAYOUT, numparameters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int numparameters
     * }
     */
    public static void numparameters(MemorySegment struct, int fieldValue) {
        struct.set(numparameters$LAYOUT, numparameters$OFFSET, fieldValue);
    }

    private static final AddressLayout paramdesc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("paramdesc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_PARAMETER_DESC **paramdesc
     * }
     */
    public static final AddressLayout paramdesc$layout() {
        return paramdesc$LAYOUT;
    }

    private static final long paramdesc$OFFSET = $LAYOUT.byteOffset(groupElement("paramdesc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_PARAMETER_DESC **paramdesc
     * }
     */
    public static final long paramdesc$offset() {
        return paramdesc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_PARAMETER_DESC **paramdesc
     * }
     */
    public static MemorySegment paramdesc(MemorySegment struct) {
        return struct.get(paramdesc$LAYOUT, paramdesc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_PARAMETER_DESC **paramdesc
     * }
     */
    public static void paramdesc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(paramdesc$LAYOUT, paramdesc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_FLOAT_CALLBACK setparameterfloat
     * }
     */
    public final static class setparameterfloat {

        private setparameterfloat() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(setparameterfloat.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(setparameterfloat.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, float _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout setparameterfloat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("setparameterfloat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_FLOAT_CALLBACK setparameterfloat
     * }
     */
    public static final AddressLayout setparameterfloat$layout() {
        return setparameterfloat$LAYOUT;
    }

    private static final long setparameterfloat$OFFSET = $LAYOUT.byteOffset(groupElement("setparameterfloat"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_FLOAT_CALLBACK setparameterfloat
     * }
     */
    public static final long setparameterfloat$offset() {
        return setparameterfloat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_FLOAT_CALLBACK setparameterfloat
     * }
     */
    public static MemorySegment setparameterfloat(MemorySegment struct) {
        return struct.get(setparameterfloat$LAYOUT, setparameterfloat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_FLOAT_CALLBACK setparameterfloat
     * }
     */
    public static void setparameterfloat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(setparameterfloat$LAYOUT, setparameterfloat$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_INT_CALLBACK setparameterint
     * }
     */
    public final static class setparameterint {

        private setparameterint() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(setparameterint.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(setparameterint.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout setparameterint$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("setparameterint"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_INT_CALLBACK setparameterint
     * }
     */
    public static final AddressLayout setparameterint$layout() {
        return setparameterint$LAYOUT;
    }

    private static final long setparameterint$OFFSET = $LAYOUT.byteOffset(groupElement("setparameterint"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_INT_CALLBACK setparameterint
     * }
     */
    public static final long setparameterint$offset() {
        return setparameterint$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_INT_CALLBACK setparameterint
     * }
     */
    public static MemorySegment setparameterint(MemorySegment struct) {
        return struct.get(setparameterint$LAYOUT, setparameterint$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_INT_CALLBACK setparameterint
     * }
     */
    public static void setparameterint(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(setparameterint$LAYOUT, setparameterint$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_BOOL_CALLBACK setparameterbool
     * }
     */
    public final static class setparameterbool {

        private setparameterbool() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(setparameterbool.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(setparameterbool.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout setparameterbool$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("setparameterbool"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_BOOL_CALLBACK setparameterbool
     * }
     */
    public static final AddressLayout setparameterbool$layout() {
        return setparameterbool$LAYOUT;
    }

    private static final long setparameterbool$OFFSET = $LAYOUT.byteOffset(groupElement("setparameterbool"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_BOOL_CALLBACK setparameterbool
     * }
     */
    public static final long setparameterbool$offset() {
        return setparameterbool$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_BOOL_CALLBACK setparameterbool
     * }
     */
    public static MemorySegment setparameterbool(MemorySegment struct) {
        return struct.get(setparameterbool$LAYOUT, setparameterbool$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_BOOL_CALLBACK setparameterbool
     * }
     */
    public static void setparameterbool(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(setparameterbool$LAYOUT, setparameterbool$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_DATA_CALLBACK setparameterdata
     * }
     */
    public final static class setparameterdata {

        private setparameterdata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(setparameterdata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(setparameterdata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout setparameterdata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("setparameterdata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_DATA_CALLBACK setparameterdata
     * }
     */
    public static final AddressLayout setparameterdata$layout() {
        return setparameterdata$LAYOUT;
    }

    private static final long setparameterdata$OFFSET = $LAYOUT.byteOffset(groupElement("setparameterdata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_DATA_CALLBACK setparameterdata
     * }
     */
    public static final long setparameterdata$offset() {
        return setparameterdata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_DATA_CALLBACK setparameterdata
     * }
     */
    public static MemorySegment setparameterdata(MemorySegment struct) {
        return struct.get(setparameterdata$LAYOUT, setparameterdata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SETPARAM_DATA_CALLBACK setparameterdata
     * }
     */
    public static void setparameterdata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(setparameterdata$LAYOUT, setparameterdata$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_FLOAT_CALLBACK getparameterfloat
     * }
     */
    public final static class getparameterfloat {

        private getparameterfloat() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(getparameterfloat.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getparameterfloat.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getparameterfloat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getparameterfloat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_FLOAT_CALLBACK getparameterfloat
     * }
     */
    public static final AddressLayout getparameterfloat$layout() {
        return getparameterfloat$LAYOUT;
    }

    private static final long getparameterfloat$OFFSET = $LAYOUT.byteOffset(groupElement("getparameterfloat"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_FLOAT_CALLBACK getparameterfloat
     * }
     */
    public static final long getparameterfloat$offset() {
        return getparameterfloat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_FLOAT_CALLBACK getparameterfloat
     * }
     */
    public static MemorySegment getparameterfloat(MemorySegment struct) {
        return struct.get(getparameterfloat$LAYOUT, getparameterfloat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_FLOAT_CALLBACK getparameterfloat
     * }
     */
    public static void getparameterfloat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getparameterfloat$LAYOUT, getparameterfloat$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_INT_CALLBACK getparameterint
     * }
     */
    public final static class getparameterint {

        private getparameterint() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(getparameterint.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getparameterint.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getparameterint$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getparameterint"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_INT_CALLBACK getparameterint
     * }
     */
    public static final AddressLayout getparameterint$layout() {
        return getparameterint$LAYOUT;
    }

    private static final long getparameterint$OFFSET = $LAYOUT.byteOffset(groupElement("getparameterint"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_INT_CALLBACK getparameterint
     * }
     */
    public static final long getparameterint$offset() {
        return getparameterint$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_INT_CALLBACK getparameterint
     * }
     */
    public static MemorySegment getparameterint(MemorySegment struct) {
        return struct.get(getparameterint$LAYOUT, getparameterint$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_INT_CALLBACK getparameterint
     * }
     */
    public static void getparameterint(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getparameterint$LAYOUT, getparameterint$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_BOOL_CALLBACK getparameterbool
     * }
     */
    public final static class getparameterbool {

        private getparameterbool() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(getparameterbool.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getparameterbool.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getparameterbool$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getparameterbool"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_BOOL_CALLBACK getparameterbool
     * }
     */
    public static final AddressLayout getparameterbool$layout() {
        return getparameterbool$LAYOUT;
    }

    private static final long getparameterbool$OFFSET = $LAYOUT.byteOffset(groupElement("getparameterbool"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_BOOL_CALLBACK getparameterbool
     * }
     */
    public static final long getparameterbool$offset() {
        return getparameterbool$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_BOOL_CALLBACK getparameterbool
     * }
     */
    public static MemorySegment getparameterbool(MemorySegment struct) {
        return struct.get(getparameterbool$LAYOUT, getparameterbool$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_BOOL_CALLBACK getparameterbool
     * }
     */
    public static void getparameterbool(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getparameterbool$LAYOUT, getparameterbool$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_DATA_CALLBACK getparameterdata
     * }
     */
    public final static class getparameterdata {

        private getparameterdata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(getparameterdata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getparameterdata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getparameterdata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getparameterdata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_DATA_CALLBACK getparameterdata
     * }
     */
    public static final AddressLayout getparameterdata$layout() {
        return getparameterdata$LAYOUT;
    }

    private static final long getparameterdata$OFFSET = $LAYOUT.byteOffset(groupElement("getparameterdata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_DATA_CALLBACK getparameterdata
     * }
     */
    public static final long getparameterdata$offset() {
        return getparameterdata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_DATA_CALLBACK getparameterdata
     * }
     */
    public static MemorySegment getparameterdata(MemorySegment struct) {
        return struct.get(getparameterdata$LAYOUT, getparameterdata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_GETPARAM_DATA_CALLBACK getparameterdata
     * }
     */
    public static void getparameterdata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getparameterdata$LAYOUT, getparameterdata$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SHOULDIPROCESS_CALLBACK shouldiprocess
     * }
     */
    public final static class shouldiprocess {

        private shouldiprocess() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3, int _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(shouldiprocess.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(shouldiprocess.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, int _x3, int _x4, int _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout shouldiprocess$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("shouldiprocess"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SHOULDIPROCESS_CALLBACK shouldiprocess
     * }
     */
    public static final AddressLayout shouldiprocess$layout() {
        return shouldiprocess$LAYOUT;
    }

    private static final long shouldiprocess$OFFSET = $LAYOUT.byteOffset(groupElement("shouldiprocess"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SHOULDIPROCESS_CALLBACK shouldiprocess
     * }
     */
    public static final long shouldiprocess$offset() {
        return shouldiprocess$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SHOULDIPROCESS_CALLBACK shouldiprocess
     * }
     */
    public static MemorySegment shouldiprocess(MemorySegment struct) {
        return struct.get(shouldiprocess$LAYOUT, shouldiprocess$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SHOULDIPROCESS_CALLBACK shouldiprocess
     * }
     */
    public static void shouldiprocess(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(shouldiprocess$LAYOUT, shouldiprocess$OFFSET, fieldValue);
    }

    private static final AddressLayout userdata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("userdata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *userdata
     * }
     */
    public static final AddressLayout userdata$layout() {
        return userdata$LAYOUT;
    }

    private static final long userdata$OFFSET = $LAYOUT.byteOffset(groupElement("userdata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *userdata
     * }
     */
    public static final long userdata$offset() {
        return userdata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *userdata
     * }
     */
    public static MemorySegment userdata(MemorySegment struct) {
        return struct.get(userdata$LAYOUT, userdata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *userdata
     * }
     */
    public static void userdata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(userdata$LAYOUT, userdata$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_REGISTER_CALLBACK sys_register
     * }
     */
    public final static class sys_register {

        private sys_register() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(sys_register.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sys_register.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sys_register$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sys_register"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_REGISTER_CALLBACK sys_register
     * }
     */
    public static final AddressLayout sys_register$layout() {
        return sys_register$LAYOUT;
    }

    private static final long sys_register$OFFSET = $LAYOUT.byteOffset(groupElement("sys_register"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_REGISTER_CALLBACK sys_register
     * }
     */
    public static final long sys_register$offset() {
        return sys_register$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_REGISTER_CALLBACK sys_register
     * }
     */
    public static MemorySegment sys_register(MemorySegment struct) {
        return struct.get(sys_register$LAYOUT, sys_register$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_REGISTER_CALLBACK sys_register
     * }
     */
    public static void sys_register(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sys_register$LAYOUT, sys_register$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister
     * }
     */
    public final static class sys_deregister {

        private sys_deregister() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(sys_deregister.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sys_deregister.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sys_deregister$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sys_deregister"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister
     * }
     */
    public static final AddressLayout sys_deregister$layout() {
        return sys_deregister$LAYOUT;
    }

    private static final long sys_deregister$OFFSET = $LAYOUT.byteOffset(groupElement("sys_deregister"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister
     * }
     */
    public static final long sys_deregister$offset() {
        return sys_deregister$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister
     * }
     */
    public static MemorySegment sys_deregister(MemorySegment struct) {
        return struct.get(sys_deregister$LAYOUT, sys_deregister$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister
     * }
     */
    public static void sys_deregister(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sys_deregister$LAYOUT, sys_deregister$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_MIX_CALLBACK sys_mix
     * }
     */
    public final static class sys_mix {

        private sys_mix() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(sys_mix.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(sys_mix.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout sys_mix$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("sys_mix"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_MIX_CALLBACK sys_mix
     * }
     */
    public static final AddressLayout sys_mix$layout() {
        return sys_mix$LAYOUT;
    }

    private static final long sys_mix$OFFSET = $LAYOUT.byteOffset(groupElement("sys_mix"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_MIX_CALLBACK sys_mix
     * }
     */
    public static final long sys_mix$offset() {
        return sys_mix$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_MIX_CALLBACK sys_mix
     * }
     */
    public static MemorySegment sys_mix(MemorySegment struct) {
        return struct.get(sys_mix$LAYOUT, sys_mix$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_DSP_SYSTEM_MIX_CALLBACK sys_mix
     * }
     */
    public static void sys_mix(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(sys_mix$LAYOUT, sys_mix$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

