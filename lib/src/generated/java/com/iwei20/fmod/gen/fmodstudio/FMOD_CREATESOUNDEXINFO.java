// Generated by jextract

package com.iwei20.fmod.gen.fmodstudio;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct FMOD_CREATESOUNDEXINFO {
 *     int cbsize;
 *     unsigned int length;
 *     unsigned int fileoffset;
 *     int numchannels;
 *     int defaultfrequency;
 *     FMOD_SOUND_FORMAT format;
 *     unsigned int decodebuffersize;
 *     int initialsubsound;
 *     int numsubsounds;
 *     int *inclusionlist;
 *     int inclusionlistnum;
 *     FMOD_SOUND_PCMREAD_CALLBACK pcmreadcallback;
 *     FMOD_SOUND_PCMSETPOS_CALLBACK pcmsetposcallback;
 *     FMOD_SOUND_NONBLOCK_CALLBACK nonblockcallback;
 *     const char *dlsname;
 *     const char *encryptionkey;
 *     int maxpolyphony;
 *     void *userdata;
 *     FMOD_SOUND_TYPE suggestedsoundtype;
 *     FMOD_FILE_OPEN_CALLBACK fileuseropen;
 *     FMOD_FILE_CLOSE_CALLBACK fileuserclose;
 *     FMOD_FILE_READ_CALLBACK fileuserread;
 *     FMOD_FILE_SEEK_CALLBACK fileuserseek;
 *     FMOD_FILE_ASYNCREAD_CALLBACK fileuserasyncread;
 *     FMOD_FILE_ASYNCCANCEL_CALLBACK fileuserasynccancel;
 *     void *fileuserdata;
 *     int filebuffersize;
 *     FMOD_CHANNELORDER channelorder;
 *     FMOD_SOUNDGROUP *initialsoundgroup;
 *     unsigned int initialseekposition;
 *     FMOD_TIMEUNIT initialseekpostype;
 *     int ignoresetfilesystem;
 *     unsigned int audioqueuepolicy;
 *     unsigned int minmidigranularity;
 *     int nonblockthreadid;
 *     FMOD_GUID *fsbguid;
 * }
 * }
 */
public class FMOD_CREATESOUNDEXINFO {

    FMOD_CREATESOUNDEXINFO() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        fmod_studio_h.C_INT.withName("cbsize"),
        fmod_studio_h.C_INT.withName("length"),
        fmod_studio_h.C_INT.withName("fileoffset"),
        fmod_studio_h.C_INT.withName("numchannels"),
        fmod_studio_h.C_INT.withName("defaultfrequency"),
        fmod_studio_h.C_INT.withName("format"),
        fmod_studio_h.C_INT.withName("decodebuffersize"),
        fmod_studio_h.C_INT.withName("initialsubsound"),
        fmod_studio_h.C_INT.withName("numsubsounds"),
        MemoryLayout.paddingLayout(4),
        fmod_studio_h.C_POINTER.withName("inclusionlist"),
        fmod_studio_h.C_INT.withName("inclusionlistnum"),
        MemoryLayout.paddingLayout(4),
        fmod_studio_h.C_POINTER.withName("pcmreadcallback"),
        fmod_studio_h.C_POINTER.withName("pcmsetposcallback"),
        fmod_studio_h.C_POINTER.withName("nonblockcallback"),
        fmod_studio_h.C_POINTER.withName("dlsname"),
        fmod_studio_h.C_POINTER.withName("encryptionkey"),
        fmod_studio_h.C_INT.withName("maxpolyphony"),
        MemoryLayout.paddingLayout(4),
        fmod_studio_h.C_POINTER.withName("userdata"),
        fmod_studio_h.C_INT.withName("suggestedsoundtype"),
        MemoryLayout.paddingLayout(4),
        fmod_studio_h.C_POINTER.withName("fileuseropen"),
        fmod_studio_h.C_POINTER.withName("fileuserclose"),
        fmod_studio_h.C_POINTER.withName("fileuserread"),
        fmod_studio_h.C_POINTER.withName("fileuserseek"),
        fmod_studio_h.C_POINTER.withName("fileuserasyncread"),
        fmod_studio_h.C_POINTER.withName("fileuserasynccancel"),
        fmod_studio_h.C_POINTER.withName("fileuserdata"),
        fmod_studio_h.C_INT.withName("filebuffersize"),
        fmod_studio_h.C_INT.withName("channelorder"),
        fmod_studio_h.C_POINTER.withName("initialsoundgroup"),
        fmod_studio_h.C_INT.withName("initialseekposition"),
        fmod_studio_h.C_INT.withName("initialseekpostype"),
        fmod_studio_h.C_INT.withName("ignoresetfilesystem"),
        fmod_studio_h.C_INT.withName("audioqueuepolicy"),
        fmod_studio_h.C_INT.withName("minmidigranularity"),
        fmod_studio_h.C_INT.withName("nonblockthreadid"),
        fmod_studio_h.C_POINTER.withName("fsbguid")
    ).withName("FMOD_CREATESOUNDEXINFO");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt cbsize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("cbsize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int cbsize
     * }
     */
    public static final OfInt cbsize$layout() {
        return cbsize$LAYOUT;
    }

    private static final long cbsize$OFFSET = $LAYOUT.byteOffset(groupElement("cbsize"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int cbsize
     * }
     */
    public static final long cbsize$offset() {
        return cbsize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int cbsize
     * }
     */
    public static int cbsize(MemorySegment struct) {
        return struct.get(cbsize$LAYOUT, cbsize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int cbsize
     * }
     */
    public static void cbsize(MemorySegment struct, int fieldValue) {
        struct.set(cbsize$LAYOUT, cbsize$OFFSET, fieldValue);
    }

    private static final OfInt length$LAYOUT = (OfInt)$LAYOUT.select(groupElement("length"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int length
     * }
     */
    public static final OfInt length$layout() {
        return length$LAYOUT;
    }

    private static final long length$OFFSET = $LAYOUT.byteOffset(groupElement("length"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int length
     * }
     */
    public static final long length$offset() {
        return length$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int length
     * }
     */
    public static int length(MemorySegment struct) {
        return struct.get(length$LAYOUT, length$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int length
     * }
     */
    public static void length(MemorySegment struct, int fieldValue) {
        struct.set(length$LAYOUT, length$OFFSET, fieldValue);
    }

    private static final OfInt fileoffset$LAYOUT = (OfInt)$LAYOUT.select(groupElement("fileoffset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int fileoffset
     * }
     */
    public static final OfInt fileoffset$layout() {
        return fileoffset$LAYOUT;
    }

    private static final long fileoffset$OFFSET = $LAYOUT.byteOffset(groupElement("fileoffset"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int fileoffset
     * }
     */
    public static final long fileoffset$offset() {
        return fileoffset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int fileoffset
     * }
     */
    public static int fileoffset(MemorySegment struct) {
        return struct.get(fileoffset$LAYOUT, fileoffset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int fileoffset
     * }
     */
    public static void fileoffset(MemorySegment struct, int fieldValue) {
        struct.set(fileoffset$LAYOUT, fileoffset$OFFSET, fieldValue);
    }

    private static final OfInt numchannels$LAYOUT = (OfInt)$LAYOUT.select(groupElement("numchannels"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int numchannels
     * }
     */
    public static final OfInt numchannels$layout() {
        return numchannels$LAYOUT;
    }

    private static final long numchannels$OFFSET = $LAYOUT.byteOffset(groupElement("numchannels"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int numchannels
     * }
     */
    public static final long numchannels$offset() {
        return numchannels$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int numchannels
     * }
     */
    public static int numchannels(MemorySegment struct) {
        return struct.get(numchannels$LAYOUT, numchannels$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int numchannels
     * }
     */
    public static void numchannels(MemorySegment struct, int fieldValue) {
        struct.set(numchannels$LAYOUT, numchannels$OFFSET, fieldValue);
    }

    private static final OfInt defaultfrequency$LAYOUT = (OfInt)$LAYOUT.select(groupElement("defaultfrequency"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int defaultfrequency
     * }
     */
    public static final OfInt defaultfrequency$layout() {
        return defaultfrequency$LAYOUT;
    }

    private static final long defaultfrequency$OFFSET = $LAYOUT.byteOffset(groupElement("defaultfrequency"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int defaultfrequency
     * }
     */
    public static final long defaultfrequency$offset() {
        return defaultfrequency$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int defaultfrequency
     * }
     */
    public static int defaultfrequency(MemorySegment struct) {
        return struct.get(defaultfrequency$LAYOUT, defaultfrequency$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int defaultfrequency
     * }
     */
    public static void defaultfrequency(MemorySegment struct, int fieldValue) {
        struct.set(defaultfrequency$LAYOUT, defaultfrequency$OFFSET, fieldValue);
    }

    private static final OfInt format$LAYOUT = (OfInt)$LAYOUT.select(groupElement("format"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_SOUND_FORMAT format
     * }
     */
    public static final OfInt format$layout() {
        return format$LAYOUT;
    }

    private static final long format$OFFSET = $LAYOUT.byteOffset(groupElement("format"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_SOUND_FORMAT format
     * }
     */
    public static final long format$offset() {
        return format$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_FORMAT format
     * }
     */
    public static int format(MemorySegment struct) {
        return struct.get(format$LAYOUT, format$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_FORMAT format
     * }
     */
    public static void format(MemorySegment struct, int fieldValue) {
        struct.set(format$LAYOUT, format$OFFSET, fieldValue);
    }

    private static final OfInt decodebuffersize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("decodebuffersize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int decodebuffersize
     * }
     */
    public static final OfInt decodebuffersize$layout() {
        return decodebuffersize$LAYOUT;
    }

    private static final long decodebuffersize$OFFSET = $LAYOUT.byteOffset(groupElement("decodebuffersize"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int decodebuffersize
     * }
     */
    public static final long decodebuffersize$offset() {
        return decodebuffersize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int decodebuffersize
     * }
     */
    public static int decodebuffersize(MemorySegment struct) {
        return struct.get(decodebuffersize$LAYOUT, decodebuffersize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int decodebuffersize
     * }
     */
    public static void decodebuffersize(MemorySegment struct, int fieldValue) {
        struct.set(decodebuffersize$LAYOUT, decodebuffersize$OFFSET, fieldValue);
    }

    private static final OfInt initialsubsound$LAYOUT = (OfInt)$LAYOUT.select(groupElement("initialsubsound"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int initialsubsound
     * }
     */
    public static final OfInt initialsubsound$layout() {
        return initialsubsound$LAYOUT;
    }

    private static final long initialsubsound$OFFSET = $LAYOUT.byteOffset(groupElement("initialsubsound"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int initialsubsound
     * }
     */
    public static final long initialsubsound$offset() {
        return initialsubsound$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int initialsubsound
     * }
     */
    public static int initialsubsound(MemorySegment struct) {
        return struct.get(initialsubsound$LAYOUT, initialsubsound$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int initialsubsound
     * }
     */
    public static void initialsubsound(MemorySegment struct, int fieldValue) {
        struct.set(initialsubsound$LAYOUT, initialsubsound$OFFSET, fieldValue);
    }

    private static final OfInt numsubsounds$LAYOUT = (OfInt)$LAYOUT.select(groupElement("numsubsounds"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int numsubsounds
     * }
     */
    public static final OfInt numsubsounds$layout() {
        return numsubsounds$LAYOUT;
    }

    private static final long numsubsounds$OFFSET = $LAYOUT.byteOffset(groupElement("numsubsounds"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int numsubsounds
     * }
     */
    public static final long numsubsounds$offset() {
        return numsubsounds$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int numsubsounds
     * }
     */
    public static int numsubsounds(MemorySegment struct) {
        return struct.get(numsubsounds$LAYOUT, numsubsounds$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int numsubsounds
     * }
     */
    public static void numsubsounds(MemorySegment struct, int fieldValue) {
        struct.set(numsubsounds$LAYOUT, numsubsounds$OFFSET, fieldValue);
    }

    private static final AddressLayout inclusionlist$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("inclusionlist"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int *inclusionlist
     * }
     */
    public static final AddressLayout inclusionlist$layout() {
        return inclusionlist$LAYOUT;
    }

    private static final long inclusionlist$OFFSET = $LAYOUT.byteOffset(groupElement("inclusionlist"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int *inclusionlist
     * }
     */
    public static final long inclusionlist$offset() {
        return inclusionlist$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int *inclusionlist
     * }
     */
    public static MemorySegment inclusionlist(MemorySegment struct) {
        return struct.get(inclusionlist$LAYOUT, inclusionlist$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int *inclusionlist
     * }
     */
    public static void inclusionlist(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(inclusionlist$LAYOUT, inclusionlist$OFFSET, fieldValue);
    }

    private static final OfInt inclusionlistnum$LAYOUT = (OfInt)$LAYOUT.select(groupElement("inclusionlistnum"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int inclusionlistnum
     * }
     */
    public static final OfInt inclusionlistnum$layout() {
        return inclusionlistnum$LAYOUT;
    }

    private static final long inclusionlistnum$OFFSET = $LAYOUT.byteOffset(groupElement("inclusionlistnum"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int inclusionlistnum
     * }
     */
    public static final long inclusionlistnum$offset() {
        return inclusionlistnum$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int inclusionlistnum
     * }
     */
    public static int inclusionlistnum(MemorySegment struct) {
        return struct.get(inclusionlistnum$LAYOUT, inclusionlistnum$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int inclusionlistnum
     * }
     */
    public static void inclusionlistnum(MemorySegment struct, int fieldValue) {
        struct.set(inclusionlistnum$LAYOUT, inclusionlistnum$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_SOUND_PCMREAD_CALLBACK pcmreadcallback
     * }
     */
    public final static class pcmreadcallback {

        private pcmreadcallback() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(pcmreadcallback.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(pcmreadcallback.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout pcmreadcallback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pcmreadcallback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_SOUND_PCMREAD_CALLBACK pcmreadcallback
     * }
     */
    public static final AddressLayout pcmreadcallback$layout() {
        return pcmreadcallback$LAYOUT;
    }

    private static final long pcmreadcallback$OFFSET = $LAYOUT.byteOffset(groupElement("pcmreadcallback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_SOUND_PCMREAD_CALLBACK pcmreadcallback
     * }
     */
    public static final long pcmreadcallback$offset() {
        return pcmreadcallback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_PCMREAD_CALLBACK pcmreadcallback
     * }
     */
    public static MemorySegment pcmreadcallback(MemorySegment struct) {
        return struct.get(pcmreadcallback$LAYOUT, pcmreadcallback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_PCMREAD_CALLBACK pcmreadcallback
     * }
     */
    public static void pcmreadcallback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pcmreadcallback$LAYOUT, pcmreadcallback$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_SOUND_PCMSETPOS_CALLBACK pcmsetposcallback
     * }
     */
    public final static class pcmsetposcallback {

        private pcmsetposcallback() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(pcmsetposcallback.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(pcmsetposcallback.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout pcmsetposcallback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pcmsetposcallback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_SOUND_PCMSETPOS_CALLBACK pcmsetposcallback
     * }
     */
    public static final AddressLayout pcmsetposcallback$layout() {
        return pcmsetposcallback$LAYOUT;
    }

    private static final long pcmsetposcallback$OFFSET = $LAYOUT.byteOffset(groupElement("pcmsetposcallback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_SOUND_PCMSETPOS_CALLBACK pcmsetposcallback
     * }
     */
    public static final long pcmsetposcallback$offset() {
        return pcmsetposcallback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_PCMSETPOS_CALLBACK pcmsetposcallback
     * }
     */
    public static MemorySegment pcmsetposcallback(MemorySegment struct) {
        return struct.get(pcmsetposcallback$LAYOUT, pcmsetposcallback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_PCMSETPOS_CALLBACK pcmsetposcallback
     * }
     */
    public static void pcmsetposcallback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pcmsetposcallback$LAYOUT, pcmsetposcallback$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_SOUND_NONBLOCK_CALLBACK nonblockcallback
     * }
     */
    public final static class nonblockcallback {

        private nonblockcallback() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(nonblockcallback.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(nonblockcallback.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout nonblockcallback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("nonblockcallback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_SOUND_NONBLOCK_CALLBACK nonblockcallback
     * }
     */
    public static final AddressLayout nonblockcallback$layout() {
        return nonblockcallback$LAYOUT;
    }

    private static final long nonblockcallback$OFFSET = $LAYOUT.byteOffset(groupElement("nonblockcallback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_SOUND_NONBLOCK_CALLBACK nonblockcallback
     * }
     */
    public static final long nonblockcallback$offset() {
        return nonblockcallback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_NONBLOCK_CALLBACK nonblockcallback
     * }
     */
    public static MemorySegment nonblockcallback(MemorySegment struct) {
        return struct.get(nonblockcallback$LAYOUT, nonblockcallback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_NONBLOCK_CALLBACK nonblockcallback
     * }
     */
    public static void nonblockcallback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(nonblockcallback$LAYOUT, nonblockcallback$OFFSET, fieldValue);
    }

    private static final AddressLayout dlsname$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dlsname"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *dlsname
     * }
     */
    public static final AddressLayout dlsname$layout() {
        return dlsname$LAYOUT;
    }

    private static final long dlsname$OFFSET = $LAYOUT.byteOffset(groupElement("dlsname"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *dlsname
     * }
     */
    public static final long dlsname$offset() {
        return dlsname$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *dlsname
     * }
     */
    public static MemorySegment dlsname(MemorySegment struct) {
        return struct.get(dlsname$LAYOUT, dlsname$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *dlsname
     * }
     */
    public static void dlsname(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dlsname$LAYOUT, dlsname$OFFSET, fieldValue);
    }

    private static final AddressLayout encryptionkey$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("encryptionkey"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *encryptionkey
     * }
     */
    public static final AddressLayout encryptionkey$layout() {
        return encryptionkey$LAYOUT;
    }

    private static final long encryptionkey$OFFSET = $LAYOUT.byteOffset(groupElement("encryptionkey"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *encryptionkey
     * }
     */
    public static final long encryptionkey$offset() {
        return encryptionkey$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *encryptionkey
     * }
     */
    public static MemorySegment encryptionkey(MemorySegment struct) {
        return struct.get(encryptionkey$LAYOUT, encryptionkey$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *encryptionkey
     * }
     */
    public static void encryptionkey(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(encryptionkey$LAYOUT, encryptionkey$OFFSET, fieldValue);
    }

    private static final OfInt maxpolyphony$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxpolyphony"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int maxpolyphony
     * }
     */
    public static final OfInt maxpolyphony$layout() {
        return maxpolyphony$LAYOUT;
    }

    private static final long maxpolyphony$OFFSET = $LAYOUT.byteOffset(groupElement("maxpolyphony"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int maxpolyphony
     * }
     */
    public static final long maxpolyphony$offset() {
        return maxpolyphony$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int maxpolyphony
     * }
     */
    public static int maxpolyphony(MemorySegment struct) {
        return struct.get(maxpolyphony$LAYOUT, maxpolyphony$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int maxpolyphony
     * }
     */
    public static void maxpolyphony(MemorySegment struct, int fieldValue) {
        struct.set(maxpolyphony$LAYOUT, maxpolyphony$OFFSET, fieldValue);
    }

    private static final AddressLayout userdata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("userdata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *userdata
     * }
     */
    public static final AddressLayout userdata$layout() {
        return userdata$LAYOUT;
    }

    private static final long userdata$OFFSET = $LAYOUT.byteOffset(groupElement("userdata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *userdata
     * }
     */
    public static final long userdata$offset() {
        return userdata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *userdata
     * }
     */
    public static MemorySegment userdata(MemorySegment struct) {
        return struct.get(userdata$LAYOUT, userdata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *userdata
     * }
     */
    public static void userdata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(userdata$LAYOUT, userdata$OFFSET, fieldValue);
    }

    private static final OfInt suggestedsoundtype$LAYOUT = (OfInt)$LAYOUT.select(groupElement("suggestedsoundtype"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_SOUND_TYPE suggestedsoundtype
     * }
     */
    public static final OfInt suggestedsoundtype$layout() {
        return suggestedsoundtype$LAYOUT;
    }

    private static final long suggestedsoundtype$OFFSET = $LAYOUT.byteOffset(groupElement("suggestedsoundtype"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_SOUND_TYPE suggestedsoundtype
     * }
     */
    public static final long suggestedsoundtype$offset() {
        return suggestedsoundtype$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_TYPE suggestedsoundtype
     * }
     */
    public static int suggestedsoundtype(MemorySegment struct) {
        return struct.get(suggestedsoundtype$LAYOUT, suggestedsoundtype$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_SOUND_TYPE suggestedsoundtype
     * }
     */
    public static void suggestedsoundtype(MemorySegment struct, int fieldValue) {
        struct.set(suggestedsoundtype$LAYOUT, suggestedsoundtype$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_FILE_OPEN_CALLBACK fileuseropen
     * }
     */
    public final static class fileuseropen {

        private fileuseropen() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(fileuseropen.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fileuseropen.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fileuseropen$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fileuseropen"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_FILE_OPEN_CALLBACK fileuseropen
     * }
     */
    public static final AddressLayout fileuseropen$layout() {
        return fileuseropen$LAYOUT;
    }

    private static final long fileuseropen$OFFSET = $LAYOUT.byteOffset(groupElement("fileuseropen"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_FILE_OPEN_CALLBACK fileuseropen
     * }
     */
    public static final long fileuseropen$offset() {
        return fileuseropen$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_FILE_OPEN_CALLBACK fileuseropen
     * }
     */
    public static MemorySegment fileuseropen(MemorySegment struct) {
        return struct.get(fileuseropen$LAYOUT, fileuseropen$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_FILE_OPEN_CALLBACK fileuseropen
     * }
     */
    public static void fileuseropen(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fileuseropen$LAYOUT, fileuseropen$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_FILE_CLOSE_CALLBACK fileuserclose
     * }
     */
    public final static class fileuserclose {

        private fileuserclose() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(fileuserclose.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fileuserclose.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fileuserclose$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fileuserclose"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_FILE_CLOSE_CALLBACK fileuserclose
     * }
     */
    public static final AddressLayout fileuserclose$layout() {
        return fileuserclose$LAYOUT;
    }

    private static final long fileuserclose$OFFSET = $LAYOUT.byteOffset(groupElement("fileuserclose"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_FILE_CLOSE_CALLBACK fileuserclose
     * }
     */
    public static final long fileuserclose$offset() {
        return fileuserclose$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_FILE_CLOSE_CALLBACK fileuserclose
     * }
     */
    public static MemorySegment fileuserclose(MemorySegment struct) {
        return struct.get(fileuserclose$LAYOUT, fileuserclose$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_FILE_CLOSE_CALLBACK fileuserclose
     * }
     */
    public static void fileuserclose(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fileuserclose$LAYOUT, fileuserclose$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_FILE_READ_CALLBACK fileuserread
     * }
     */
    public final static class fileuserread {

        private fileuserread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(fileuserread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fileuserread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fileuserread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fileuserread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_FILE_READ_CALLBACK fileuserread
     * }
     */
    public static final AddressLayout fileuserread$layout() {
        return fileuserread$LAYOUT;
    }

    private static final long fileuserread$OFFSET = $LAYOUT.byteOffset(groupElement("fileuserread"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_FILE_READ_CALLBACK fileuserread
     * }
     */
    public static final long fileuserread$offset() {
        return fileuserread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_FILE_READ_CALLBACK fileuserread
     * }
     */
    public static MemorySegment fileuserread(MemorySegment struct) {
        return struct.get(fileuserread$LAYOUT, fileuserread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_FILE_READ_CALLBACK fileuserread
     * }
     */
    public static void fileuserread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fileuserread$LAYOUT, fileuserread$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_FILE_SEEK_CALLBACK fileuserseek
     * }
     */
    public final static class fileuserseek {

        private fileuserseek() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(fileuserseek.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fileuserseek.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fileuserseek$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fileuserseek"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_FILE_SEEK_CALLBACK fileuserseek
     * }
     */
    public static final AddressLayout fileuserseek$layout() {
        return fileuserseek$LAYOUT;
    }

    private static final long fileuserseek$OFFSET = $LAYOUT.byteOffset(groupElement("fileuserseek"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_FILE_SEEK_CALLBACK fileuserseek
     * }
     */
    public static final long fileuserseek$offset() {
        return fileuserseek$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_FILE_SEEK_CALLBACK fileuserseek
     * }
     */
    public static MemorySegment fileuserseek(MemorySegment struct) {
        return struct.get(fileuserseek$LAYOUT, fileuserseek$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_FILE_SEEK_CALLBACK fileuserseek
     * }
     */
    public static void fileuserseek(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fileuserseek$LAYOUT, fileuserseek$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCREAD_CALLBACK fileuserasyncread
     * }
     */
    public final static class fileuserasyncread {

        private fileuserasyncread() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(fileuserasyncread.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fileuserasyncread.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fileuserasyncread$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fileuserasyncread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCREAD_CALLBACK fileuserasyncread
     * }
     */
    public static final AddressLayout fileuserasyncread$layout() {
        return fileuserasyncread$LAYOUT;
    }

    private static final long fileuserasyncread$OFFSET = $LAYOUT.byteOffset(groupElement("fileuserasyncread"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCREAD_CALLBACK fileuserasyncread
     * }
     */
    public static final long fileuserasyncread$offset() {
        return fileuserasyncread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCREAD_CALLBACK fileuserasyncread
     * }
     */
    public static MemorySegment fileuserasyncread(MemorySegment struct) {
        return struct.get(fileuserasyncread$LAYOUT, fileuserasyncread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCREAD_CALLBACK fileuserasyncread
     * }
     */
    public static void fileuserasyncread(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fileuserasyncread$LAYOUT, fileuserasyncread$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCCANCEL_CALLBACK fileuserasynccancel
     * }
     */
    public final static class fileuserasynccancel {

        private fileuserasynccancel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(fileuserasynccancel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fileuserasynccancel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fileuserasynccancel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fileuserasynccancel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCCANCEL_CALLBACK fileuserasynccancel
     * }
     */
    public static final AddressLayout fileuserasynccancel$layout() {
        return fileuserasynccancel$LAYOUT;
    }

    private static final long fileuserasynccancel$OFFSET = $LAYOUT.byteOffset(groupElement("fileuserasynccancel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCCANCEL_CALLBACK fileuserasynccancel
     * }
     */
    public static final long fileuserasynccancel$offset() {
        return fileuserasynccancel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCCANCEL_CALLBACK fileuserasynccancel
     * }
     */
    public static MemorySegment fileuserasynccancel(MemorySegment struct) {
        return struct.get(fileuserasynccancel$LAYOUT, fileuserasynccancel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_FILE_ASYNCCANCEL_CALLBACK fileuserasynccancel
     * }
     */
    public static void fileuserasynccancel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fileuserasynccancel$LAYOUT, fileuserasynccancel$OFFSET, fieldValue);
    }

    private static final AddressLayout fileuserdata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fileuserdata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *fileuserdata
     * }
     */
    public static final AddressLayout fileuserdata$layout() {
        return fileuserdata$LAYOUT;
    }

    private static final long fileuserdata$OFFSET = $LAYOUT.byteOffset(groupElement("fileuserdata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *fileuserdata
     * }
     */
    public static final long fileuserdata$offset() {
        return fileuserdata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *fileuserdata
     * }
     */
    public static MemorySegment fileuserdata(MemorySegment struct) {
        return struct.get(fileuserdata$LAYOUT, fileuserdata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *fileuserdata
     * }
     */
    public static void fileuserdata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fileuserdata$LAYOUT, fileuserdata$OFFSET, fieldValue);
    }

    private static final OfInt filebuffersize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("filebuffersize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int filebuffersize
     * }
     */
    public static final OfInt filebuffersize$layout() {
        return filebuffersize$LAYOUT;
    }

    private static final long filebuffersize$OFFSET = $LAYOUT.byteOffset(groupElement("filebuffersize"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int filebuffersize
     * }
     */
    public static final long filebuffersize$offset() {
        return filebuffersize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int filebuffersize
     * }
     */
    public static int filebuffersize(MemorySegment struct) {
        return struct.get(filebuffersize$LAYOUT, filebuffersize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int filebuffersize
     * }
     */
    public static void filebuffersize(MemorySegment struct, int fieldValue) {
        struct.set(filebuffersize$LAYOUT, filebuffersize$OFFSET, fieldValue);
    }

    private static final OfInt channelorder$LAYOUT = (OfInt)$LAYOUT.select(groupElement("channelorder"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_CHANNELORDER channelorder
     * }
     */
    public static final OfInt channelorder$layout() {
        return channelorder$LAYOUT;
    }

    private static final long channelorder$OFFSET = $LAYOUT.byteOffset(groupElement("channelorder"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_CHANNELORDER channelorder
     * }
     */
    public static final long channelorder$offset() {
        return channelorder$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_CHANNELORDER channelorder
     * }
     */
    public static int channelorder(MemorySegment struct) {
        return struct.get(channelorder$LAYOUT, channelorder$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_CHANNELORDER channelorder
     * }
     */
    public static void channelorder(MemorySegment struct, int fieldValue) {
        struct.set(channelorder$LAYOUT, channelorder$OFFSET, fieldValue);
    }

    private static final AddressLayout initialsoundgroup$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("initialsoundgroup"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_SOUNDGROUP *initialsoundgroup
     * }
     */
    public static final AddressLayout initialsoundgroup$layout() {
        return initialsoundgroup$LAYOUT;
    }

    private static final long initialsoundgroup$OFFSET = $LAYOUT.byteOffset(groupElement("initialsoundgroup"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_SOUNDGROUP *initialsoundgroup
     * }
     */
    public static final long initialsoundgroup$offset() {
        return initialsoundgroup$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_SOUNDGROUP *initialsoundgroup
     * }
     */
    public static MemorySegment initialsoundgroup(MemorySegment struct) {
        return struct.get(initialsoundgroup$LAYOUT, initialsoundgroup$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_SOUNDGROUP *initialsoundgroup
     * }
     */
    public static void initialsoundgroup(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(initialsoundgroup$LAYOUT, initialsoundgroup$OFFSET, fieldValue);
    }

    private static final OfInt initialseekposition$LAYOUT = (OfInt)$LAYOUT.select(groupElement("initialseekposition"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int initialseekposition
     * }
     */
    public static final OfInt initialseekposition$layout() {
        return initialseekposition$LAYOUT;
    }

    private static final long initialseekposition$OFFSET = $LAYOUT.byteOffset(groupElement("initialseekposition"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int initialseekposition
     * }
     */
    public static final long initialseekposition$offset() {
        return initialseekposition$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int initialseekposition
     * }
     */
    public static int initialseekposition(MemorySegment struct) {
        return struct.get(initialseekposition$LAYOUT, initialseekposition$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int initialseekposition
     * }
     */
    public static void initialseekposition(MemorySegment struct, int fieldValue) {
        struct.set(initialseekposition$LAYOUT, initialseekposition$OFFSET, fieldValue);
    }

    private static final OfInt initialseekpostype$LAYOUT = (OfInt)$LAYOUT.select(groupElement("initialseekpostype"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_TIMEUNIT initialseekpostype
     * }
     */
    public static final OfInt initialseekpostype$layout() {
        return initialseekpostype$LAYOUT;
    }

    private static final long initialseekpostype$OFFSET = $LAYOUT.byteOffset(groupElement("initialseekpostype"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_TIMEUNIT initialseekpostype
     * }
     */
    public static final long initialseekpostype$offset() {
        return initialseekpostype$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_TIMEUNIT initialseekpostype
     * }
     */
    public static int initialseekpostype(MemorySegment struct) {
        return struct.get(initialseekpostype$LAYOUT, initialseekpostype$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_TIMEUNIT initialseekpostype
     * }
     */
    public static void initialseekpostype(MemorySegment struct, int fieldValue) {
        struct.set(initialseekpostype$LAYOUT, initialseekpostype$OFFSET, fieldValue);
    }

    private static final OfInt ignoresetfilesystem$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ignoresetfilesystem"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int ignoresetfilesystem
     * }
     */
    public static final OfInt ignoresetfilesystem$layout() {
        return ignoresetfilesystem$LAYOUT;
    }

    private static final long ignoresetfilesystem$OFFSET = $LAYOUT.byteOffset(groupElement("ignoresetfilesystem"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int ignoresetfilesystem
     * }
     */
    public static final long ignoresetfilesystem$offset() {
        return ignoresetfilesystem$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int ignoresetfilesystem
     * }
     */
    public static int ignoresetfilesystem(MemorySegment struct) {
        return struct.get(ignoresetfilesystem$LAYOUT, ignoresetfilesystem$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int ignoresetfilesystem
     * }
     */
    public static void ignoresetfilesystem(MemorySegment struct, int fieldValue) {
        struct.set(ignoresetfilesystem$LAYOUT, ignoresetfilesystem$OFFSET, fieldValue);
    }

    private static final OfInt audioqueuepolicy$LAYOUT = (OfInt)$LAYOUT.select(groupElement("audioqueuepolicy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int audioqueuepolicy
     * }
     */
    public static final OfInt audioqueuepolicy$layout() {
        return audioqueuepolicy$LAYOUT;
    }

    private static final long audioqueuepolicy$OFFSET = $LAYOUT.byteOffset(groupElement("audioqueuepolicy"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int audioqueuepolicy
     * }
     */
    public static final long audioqueuepolicy$offset() {
        return audioqueuepolicy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int audioqueuepolicy
     * }
     */
    public static int audioqueuepolicy(MemorySegment struct) {
        return struct.get(audioqueuepolicy$LAYOUT, audioqueuepolicy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int audioqueuepolicy
     * }
     */
    public static void audioqueuepolicy(MemorySegment struct, int fieldValue) {
        struct.set(audioqueuepolicy$LAYOUT, audioqueuepolicy$OFFSET, fieldValue);
    }

    private static final OfInt minmidigranularity$LAYOUT = (OfInt)$LAYOUT.select(groupElement("minmidigranularity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int minmidigranularity
     * }
     */
    public static final OfInt minmidigranularity$layout() {
        return minmidigranularity$LAYOUT;
    }

    private static final long minmidigranularity$OFFSET = $LAYOUT.byteOffset(groupElement("minmidigranularity"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int minmidigranularity
     * }
     */
    public static final long minmidigranularity$offset() {
        return minmidigranularity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int minmidigranularity
     * }
     */
    public static int minmidigranularity(MemorySegment struct) {
        return struct.get(minmidigranularity$LAYOUT, minmidigranularity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int minmidigranularity
     * }
     */
    public static void minmidigranularity(MemorySegment struct, int fieldValue) {
        struct.set(minmidigranularity$LAYOUT, minmidigranularity$OFFSET, fieldValue);
    }

    private static final OfInt nonblockthreadid$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nonblockthreadid"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int nonblockthreadid
     * }
     */
    public static final OfInt nonblockthreadid$layout() {
        return nonblockthreadid$LAYOUT;
    }

    private static final long nonblockthreadid$OFFSET = $LAYOUT.byteOffset(groupElement("nonblockthreadid"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int nonblockthreadid
     * }
     */
    public static final long nonblockthreadid$offset() {
        return nonblockthreadid$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int nonblockthreadid
     * }
     */
    public static int nonblockthreadid(MemorySegment struct) {
        return struct.get(nonblockthreadid$LAYOUT, nonblockthreadid$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int nonblockthreadid
     * }
     */
    public static void nonblockthreadid(MemorySegment struct, int fieldValue) {
        struct.set(nonblockthreadid$LAYOUT, nonblockthreadid$OFFSET, fieldValue);
    }

    private static final AddressLayout fsbguid$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fsbguid"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_GUID *fsbguid
     * }
     */
    public static final AddressLayout fsbguid$layout() {
        return fsbguid$LAYOUT;
    }

    private static final long fsbguid$OFFSET = $LAYOUT.byteOffset(groupElement("fsbguid"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_GUID *fsbguid
     * }
     */
    public static final long fsbguid$offset() {
        return fsbguid$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_GUID *fsbguid
     * }
     */
    public static MemorySegment fsbguid(MemorySegment struct) {
        return struct.get(fsbguid$LAYOUT, fsbguid$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_GUID *fsbguid
     * }
     */
    public static void fsbguid(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fsbguid$LAYOUT, fsbguid$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

