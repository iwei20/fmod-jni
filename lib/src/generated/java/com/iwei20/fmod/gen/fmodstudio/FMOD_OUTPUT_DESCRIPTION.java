// Generated by jextract

package com.iwei20.fmod.gen.fmodstudio;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct FMOD_OUTPUT_DESCRIPTION {
 *     unsigned int apiversion;
 *     const char *name;
 *     unsigned int version;
 *     FMOD_OUTPUT_METHOD method;
 *     FMOD_OUTPUT_GETNUMDRIVERS_CALLBACK getnumdrivers;
 *     FMOD_OUTPUT_GETDRIVERINFO_CALLBACK getdriverinfo;
 *     FMOD_OUTPUT_INIT_CALLBACK init;
 *     FMOD_OUTPUT_START_CALLBACK start;
 *     FMOD_OUTPUT_STOP_CALLBACK stop;
 *     FMOD_OUTPUT_CLOSE_CALLBACK close;
 *     FMOD_OUTPUT_UPDATE_CALLBACK update;
 *     FMOD_OUTPUT_GETHANDLE_CALLBACK gethandle;
 *     FMOD_OUTPUT_MIXER_CALLBACK mixer;
 *     FMOD_OUTPUT_OBJECT3DGETINFO_CALLBACK object3dgetinfo;
 *     FMOD_OUTPUT_OBJECT3DALLOC_CALLBACK object3dalloc;
 *     FMOD_OUTPUT_OBJECT3DFREE_CALLBACK object3dfree;
 *     FMOD_OUTPUT_OBJECT3DUPDATE_CALLBACK object3dupdate;
 *     FMOD_OUTPUT_OPENPORT_CALLBACK openport;
 *     FMOD_OUTPUT_CLOSEPORT_CALLBACK closeport;
 *     FMOD_OUTPUT_DEVICELISTCHANGED_CALLBACK devicelistchanged;
 * }
 * }
 */
public class FMOD_OUTPUT_DESCRIPTION {

    FMOD_OUTPUT_DESCRIPTION() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        fmod_studio_h.C_INT.withName("apiversion"),
        MemoryLayout.paddingLayout(4),
        fmod_studio_h.C_POINTER.withName("name"),
        fmod_studio_h.C_INT.withName("version"),
        fmod_studio_h.C_INT.withName("method"),
        fmod_studio_h.C_POINTER.withName("getnumdrivers"),
        fmod_studio_h.C_POINTER.withName("getdriverinfo"),
        fmod_studio_h.C_POINTER.withName("init"),
        fmod_studio_h.C_POINTER.withName("start"),
        fmod_studio_h.C_POINTER.withName("stop"),
        fmod_studio_h.C_POINTER.withName("close"),
        fmod_studio_h.C_POINTER.withName("update"),
        fmod_studio_h.C_POINTER.withName("gethandle"),
        fmod_studio_h.C_POINTER.withName("mixer"),
        fmod_studio_h.C_POINTER.withName("object3dgetinfo"),
        fmod_studio_h.C_POINTER.withName("object3dalloc"),
        fmod_studio_h.C_POINTER.withName("object3dfree"),
        fmod_studio_h.C_POINTER.withName("object3dupdate"),
        fmod_studio_h.C_POINTER.withName("openport"),
        fmod_studio_h.C_POINTER.withName("closeport"),
        fmod_studio_h.C_POINTER.withName("devicelistchanged")
    ).withName("FMOD_OUTPUT_DESCRIPTION");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt apiversion$LAYOUT = (OfInt)$LAYOUT.select(groupElement("apiversion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int apiversion
     * }
     */
    public static final OfInt apiversion$layout() {
        return apiversion$LAYOUT;
    }

    private static final long apiversion$OFFSET = $LAYOUT.byteOffset(groupElement("apiversion"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int apiversion
     * }
     */
    public static final long apiversion$offset() {
        return apiversion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int apiversion
     * }
     */
    public static int apiversion(MemorySegment struct) {
        return struct.get(apiversion$LAYOUT, apiversion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int apiversion
     * }
     */
    public static void apiversion(MemorySegment struct, int fieldValue) {
        struct.set(apiversion$LAYOUT, apiversion$OFFSET, fieldValue);
    }

    private static final AddressLayout name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static final AddressLayout name$layout() {
        return name$LAYOUT;
    }

    private static final long name$OFFSET = $LAYOUT.byteOffset(groupElement("name"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static final long name$offset() {
        return name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static MemorySegment name(MemorySegment struct) {
        return struct.get(name$LAYOUT, name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *name
     * }
     */
    public static void name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(name$LAYOUT, name$OFFSET, fieldValue);
    }

    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement("version"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final OfInt version$layout() {
        return version$LAYOUT;
    }

    private static final long version$OFFSET = $LAYOUT.byteOffset(groupElement("version"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static final long version$offset() {
        return version$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static int version(MemorySegment struct) {
        return struct.get(version$LAYOUT, version$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int version
     * }
     */
    public static void version(MemorySegment struct, int fieldValue) {
        struct.set(version$LAYOUT, version$OFFSET, fieldValue);
    }

    private static final OfInt method$LAYOUT = (OfInt)$LAYOUT.select(groupElement("method"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_METHOD method
     * }
     */
    public static final OfInt method$layout() {
        return method$LAYOUT;
    }

    private static final long method$OFFSET = $LAYOUT.byteOffset(groupElement("method"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_METHOD method
     * }
     */
    public static final long method$offset() {
        return method$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_METHOD method
     * }
     */
    public static int method(MemorySegment struct) {
        return struct.get(method$LAYOUT, method$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_METHOD method
     * }
     */
    public static void method(MemorySegment struct, int fieldValue) {
        struct.set(method$LAYOUT, method$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETNUMDRIVERS_CALLBACK getnumdrivers
     * }
     */
    public final static class getnumdrivers {

        private getnumdrivers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(getnumdrivers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getnumdrivers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getnumdrivers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getnumdrivers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETNUMDRIVERS_CALLBACK getnumdrivers
     * }
     */
    public static final AddressLayout getnumdrivers$layout() {
        return getnumdrivers$LAYOUT;
    }

    private static final long getnumdrivers$OFFSET = $LAYOUT.byteOffset(groupElement("getnumdrivers"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETNUMDRIVERS_CALLBACK getnumdrivers
     * }
     */
    public static final long getnumdrivers$offset() {
        return getnumdrivers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETNUMDRIVERS_CALLBACK getnumdrivers
     * }
     */
    public static MemorySegment getnumdrivers(MemorySegment struct) {
        return struct.get(getnumdrivers$LAYOUT, getnumdrivers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETNUMDRIVERS_CALLBACK getnumdrivers
     * }
     */
    public static void getnumdrivers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getnumdrivers$LAYOUT, getnumdrivers$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETDRIVERINFO_CALLBACK getdriverinfo
     * }
     */
    public final static class getdriverinfo {

        private getdriverinfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(getdriverinfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getdriverinfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, MemorySegment _x7) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getdriverinfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getdriverinfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETDRIVERINFO_CALLBACK getdriverinfo
     * }
     */
    public static final AddressLayout getdriverinfo$layout() {
        return getdriverinfo$LAYOUT;
    }

    private static final long getdriverinfo$OFFSET = $LAYOUT.byteOffset(groupElement("getdriverinfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETDRIVERINFO_CALLBACK getdriverinfo
     * }
     */
    public static final long getdriverinfo$offset() {
        return getdriverinfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETDRIVERINFO_CALLBACK getdriverinfo
     * }
     */
    public static MemorySegment getdriverinfo(MemorySegment struct) {
        return struct.get(getdriverinfo$LAYOUT, getdriverinfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETDRIVERINFO_CALLBACK getdriverinfo
     * }
     */
    public static void getdriverinfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getdriverinfo$LAYOUT, getdriverinfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_INIT_CALLBACK init
     * }
     */
    public final static class init {

        private init() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, int _x7, MemorySegment _x8, MemorySegment _x9, MemorySegment _x10);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(init.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(init.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6, int _x7, MemorySegment _x8, MemorySegment _x9, MemorySegment _x10) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout init$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("init"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_INIT_CALLBACK init
     * }
     */
    public static final AddressLayout init$layout() {
        return init$LAYOUT;
    }

    private static final long init$OFFSET = $LAYOUT.byteOffset(groupElement("init"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_INIT_CALLBACK init
     * }
     */
    public static final long init$offset() {
        return init$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_INIT_CALLBACK init
     * }
     */
    public static MemorySegment init(MemorySegment struct) {
        return struct.get(init$LAYOUT, init$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_INIT_CALLBACK init
     * }
     */
    public static void init(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(init$LAYOUT, init$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_START_CALLBACK start
     * }
     */
    public final static class start {

        private start() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(start.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(start.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout start$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("start"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_START_CALLBACK start
     * }
     */
    public static final AddressLayout start$layout() {
        return start$LAYOUT;
    }

    private static final long start$OFFSET = $LAYOUT.byteOffset(groupElement("start"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_START_CALLBACK start
     * }
     */
    public static final long start$offset() {
        return start$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_START_CALLBACK start
     * }
     */
    public static MemorySegment start(MemorySegment struct) {
        return struct.get(start$LAYOUT, start$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_START_CALLBACK start
     * }
     */
    public static void start(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(start$LAYOUT, start$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_STOP_CALLBACK stop
     * }
     */
    public final static class stop {

        private stop() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(stop.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(stop.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout stop$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("stop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_STOP_CALLBACK stop
     * }
     */
    public static final AddressLayout stop$layout() {
        return stop$LAYOUT;
    }

    private static final long stop$OFFSET = $LAYOUT.byteOffset(groupElement("stop"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_STOP_CALLBACK stop
     * }
     */
    public static final long stop$offset() {
        return stop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_STOP_CALLBACK stop
     * }
     */
    public static MemorySegment stop(MemorySegment struct) {
        return struct.get(stop$LAYOUT, stop$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_STOP_CALLBACK stop
     * }
     */
    public static void stop(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(stop$LAYOUT, stop$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSE_CALLBACK close
     * }
     */
    public final static class close {

        private close() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(close.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(close.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout close$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("close"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSE_CALLBACK close
     * }
     */
    public static final AddressLayout close$layout() {
        return close$LAYOUT;
    }

    private static final long close$OFFSET = $LAYOUT.byteOffset(groupElement("close"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSE_CALLBACK close
     * }
     */
    public static final long close$offset() {
        return close$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSE_CALLBACK close
     * }
     */
    public static MemorySegment close(MemorySegment struct) {
        return struct.get(close$LAYOUT, close$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSE_CALLBACK close
     * }
     */
    public static void close(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(close$LAYOUT, close$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_UPDATE_CALLBACK update
     * }
     */
    public final static class update {

        private update() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(update.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(update.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout update$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("update"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_UPDATE_CALLBACK update
     * }
     */
    public static final AddressLayout update$layout() {
        return update$LAYOUT;
    }

    private static final long update$OFFSET = $LAYOUT.byteOffset(groupElement("update"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_UPDATE_CALLBACK update
     * }
     */
    public static final long update$offset() {
        return update$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_UPDATE_CALLBACK update
     * }
     */
    public static MemorySegment update(MemorySegment struct) {
        return struct.get(update$LAYOUT, update$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_UPDATE_CALLBACK update
     * }
     */
    public static void update(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(update$LAYOUT, update$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETHANDLE_CALLBACK gethandle
     * }
     */
    public final static class gethandle {

        private gethandle() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(gethandle.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(gethandle.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout gethandle$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("gethandle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETHANDLE_CALLBACK gethandle
     * }
     */
    public static final AddressLayout gethandle$layout() {
        return gethandle$LAYOUT;
    }

    private static final long gethandle$OFFSET = $LAYOUT.byteOffset(groupElement("gethandle"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETHANDLE_CALLBACK gethandle
     * }
     */
    public static final long gethandle$offset() {
        return gethandle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETHANDLE_CALLBACK gethandle
     * }
     */
    public static MemorySegment gethandle(MemorySegment struct) {
        return struct.get(gethandle$LAYOUT, gethandle$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_GETHANDLE_CALLBACK gethandle
     * }
     */
    public static void gethandle(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(gethandle$LAYOUT, gethandle$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_MIXER_CALLBACK mixer
     * }
     */
    public final static class mixer {

        private mixer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(mixer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mixer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mixer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mixer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_MIXER_CALLBACK mixer
     * }
     */
    public static final AddressLayout mixer$layout() {
        return mixer$LAYOUT;
    }

    private static final long mixer$OFFSET = $LAYOUT.byteOffset(groupElement("mixer"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_MIXER_CALLBACK mixer
     * }
     */
    public static final long mixer$offset() {
        return mixer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_MIXER_CALLBACK mixer
     * }
     */
    public static MemorySegment mixer(MemorySegment struct) {
        return struct.get(mixer$LAYOUT, mixer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_MIXER_CALLBACK mixer
     * }
     */
    public static void mixer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mixer$LAYOUT, mixer$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DGETINFO_CALLBACK object3dgetinfo
     * }
     */
    public final static class object3dgetinfo {

        private object3dgetinfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(object3dgetinfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(object3dgetinfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout object3dgetinfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("object3dgetinfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DGETINFO_CALLBACK object3dgetinfo
     * }
     */
    public static final AddressLayout object3dgetinfo$layout() {
        return object3dgetinfo$LAYOUT;
    }

    private static final long object3dgetinfo$OFFSET = $LAYOUT.byteOffset(groupElement("object3dgetinfo"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DGETINFO_CALLBACK object3dgetinfo
     * }
     */
    public static final long object3dgetinfo$offset() {
        return object3dgetinfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DGETINFO_CALLBACK object3dgetinfo
     * }
     */
    public static MemorySegment object3dgetinfo(MemorySegment struct) {
        return struct.get(object3dgetinfo$LAYOUT, object3dgetinfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DGETINFO_CALLBACK object3dgetinfo
     * }
     */
    public static void object3dgetinfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(object3dgetinfo$LAYOUT, object3dgetinfo$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DALLOC_CALLBACK object3dalloc
     * }
     */
    public final static class object3dalloc {

        private object3dalloc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(object3dalloc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(object3dalloc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout object3dalloc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("object3dalloc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DALLOC_CALLBACK object3dalloc
     * }
     */
    public static final AddressLayout object3dalloc$layout() {
        return object3dalloc$LAYOUT;
    }

    private static final long object3dalloc$OFFSET = $LAYOUT.byteOffset(groupElement("object3dalloc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DALLOC_CALLBACK object3dalloc
     * }
     */
    public static final long object3dalloc$offset() {
        return object3dalloc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DALLOC_CALLBACK object3dalloc
     * }
     */
    public static MemorySegment object3dalloc(MemorySegment struct) {
        return struct.get(object3dalloc$LAYOUT, object3dalloc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DALLOC_CALLBACK object3dalloc
     * }
     */
    public static void object3dalloc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(object3dalloc$LAYOUT, object3dalloc$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DFREE_CALLBACK object3dfree
     * }
     */
    public final static class object3dfree {

        private object3dfree() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(object3dfree.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(object3dfree.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout object3dfree$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("object3dfree"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DFREE_CALLBACK object3dfree
     * }
     */
    public static final AddressLayout object3dfree$layout() {
        return object3dfree$LAYOUT;
    }

    private static final long object3dfree$OFFSET = $LAYOUT.byteOffset(groupElement("object3dfree"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DFREE_CALLBACK object3dfree
     * }
     */
    public static final long object3dfree$offset() {
        return object3dfree$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DFREE_CALLBACK object3dfree
     * }
     */
    public static MemorySegment object3dfree(MemorySegment struct) {
        return struct.get(object3dfree$LAYOUT, object3dfree$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DFREE_CALLBACK object3dfree
     * }
     */
    public static void object3dfree(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(object3dfree$LAYOUT, object3dfree$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DUPDATE_CALLBACK object3dupdate
     * }
     */
    public final static class object3dupdate {

        private object3dupdate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(object3dupdate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(object3dupdate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout object3dupdate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("object3dupdate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DUPDATE_CALLBACK object3dupdate
     * }
     */
    public static final AddressLayout object3dupdate$layout() {
        return object3dupdate$LAYOUT;
    }

    private static final long object3dupdate$OFFSET = $LAYOUT.byteOffset(groupElement("object3dupdate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DUPDATE_CALLBACK object3dupdate
     * }
     */
    public static final long object3dupdate$offset() {
        return object3dupdate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DUPDATE_CALLBACK object3dupdate
     * }
     */
    public static MemorySegment object3dupdate(MemorySegment struct) {
        return struct.get(object3dupdate$LAYOUT, object3dupdate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OBJECT3DUPDATE_CALLBACK object3dupdate
     * }
     */
    public static void object3dupdate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(object3dupdate$LAYOUT, object3dupdate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_OPENPORT_CALLBACK openport
     * }
     */
    public final static class openport {

        private openport() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT,
            fmod_studio_h.C_LONG_LONG,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(openport.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(openport.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, MemorySegment _x6) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout openport$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("openport"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OPENPORT_CALLBACK openport
     * }
     */
    public static final AddressLayout openport$layout() {
        return openport$LAYOUT;
    }

    private static final long openport$OFFSET = $LAYOUT.byteOffset(groupElement("openport"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OPENPORT_CALLBACK openport
     * }
     */
    public static final long openport$offset() {
        return openport$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OPENPORT_CALLBACK openport
     * }
     */
    public static MemorySegment openport(MemorySegment struct) {
        return struct.get(openport$LAYOUT, openport$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_OPENPORT_CALLBACK openport
     * }
     */
    public static void openport(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(openport$LAYOUT, openport$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSEPORT_CALLBACK closeport
     * }
     */
    public final static class closeport {

        private closeport() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER,
            fmod_studio_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(closeport.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(closeport.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout closeport$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("closeport"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSEPORT_CALLBACK closeport
     * }
     */
    public static final AddressLayout closeport$layout() {
        return closeport$LAYOUT;
    }

    private static final long closeport$OFFSET = $LAYOUT.byteOffset(groupElement("closeport"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSEPORT_CALLBACK closeport
     * }
     */
    public static final long closeport$offset() {
        return closeport$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSEPORT_CALLBACK closeport
     * }
     */
    public static MemorySegment closeport(MemorySegment struct) {
        return struct.get(closeport$LAYOUT, closeport$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_CLOSEPORT_CALLBACK closeport
     * }
     */
    public static void closeport(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(closeport$LAYOUT, closeport$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * FMOD_OUTPUT_DEVICELISTCHANGED_CALLBACK devicelistchanged
     * }
     */
    public final static class devicelistchanged {

        private devicelistchanged() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fmod_studio_h.C_INT,
            fmod_studio_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fmod_studio_h.upcallHandle(devicelistchanged.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(devicelistchanged.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout devicelistchanged$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("devicelistchanged"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_DEVICELISTCHANGED_CALLBACK devicelistchanged
     * }
     */
    public static final AddressLayout devicelistchanged$layout() {
        return devicelistchanged$LAYOUT;
    }

    private static final long devicelistchanged$OFFSET = $LAYOUT.byteOffset(groupElement("devicelistchanged"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_DEVICELISTCHANGED_CALLBACK devicelistchanged
     * }
     */
    public static final long devicelistchanged$offset() {
        return devicelistchanged$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_DEVICELISTCHANGED_CALLBACK devicelistchanged
     * }
     */
    public static MemorySegment devicelistchanged(MemorySegment struct) {
        return struct.get(devicelistchanged$LAYOUT, devicelistchanged$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FMOD_OUTPUT_DEVICELISTCHANGED_CALLBACK devicelistchanged
     * }
     */
    public static void devicelistchanged(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(devicelistchanged$LAYOUT, devicelistchanged$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

